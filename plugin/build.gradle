plugins {
  //noinspection SpellCheckingInspection
  id 'com.bmuschko.docker-remote-api'
}

import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import mybpm.CopyPreserve
import mybpm.Git

import static mybpm.Version.incrementVersionFile

dependencies {

  compileOnly "org.projectlombok:lombok:$lombokVersion"
  annotationProcessor "org.projectlombok:lombok:$lombokVersion"

  testCompileOnly "org.projectlombok:lombok:$lombokVersion"
  testAnnotationProcessor "org.projectlombok:lombok:$lombokVersion"

  compile "kz.greetgo.mybpm:plugin_share:$mybpmVersion"
  testImplementation "kz.greetgo.mybpm:mybpm_build:$mybpmVersion"
  compile "kz.greetgo:greetgo.scheduling:$greetgoSchedulerVersion"

  //noinspection GradlePackageUpdate
  compile "org.springframework:spring-web:$springWebVersion"

  testCompile "kz.greetgo.mybpm:test-register-util:$mybpmVersion"

  compileOnly "org.liquibase:liquibase-core:$liquibaseVersion"
  testCompile "org.liquibase:liquibase-core:$liquibaseVersion"
  //noinspection SpellCheckingInspection
  compileOnly "com.mattbertolini:liquibase-slf4j:$liquibaseSlf4jVersion"
  //noinspection SpellCheckingInspection
  testCompile "com.mattbertolini:liquibase-slf4j:$liquibaseSlf4jVersion"

  testCompile "kz.greetgo.util:greetgo-util:$greetgoUtilVersion"

}

sourceSets.main.resources.srcDirs += rootProject.file('versions')

jar {
  enabled = true
}

task dist(type: JavaExec) {
  group 'build'
  dependsOn jar
  classpath = sourceSets.test.runtimeClasspath
  main = "kz.greetgo.mybpm_build.PrepareJars"
  doFirst {

    delete buildDir.toPath().resolve("dist")

    args "-extern"; args rootProject.name + "/extern"
    args "-project"; args rootProject.name + "/project"

    args "-jar-base-name"; args rootProject.name
    args "-root-dir"; args rootDir.getAbsolutePath()
    args "-dist-dir"; args buildDir.toPath().resolve("dist").toFile().getAbsolutePath()
    args "-jar"; args jar.archiveFile.get().asFile.getAbsolutePath()
    for (File file : sourceSets.main.runtimeClasspath.getFiles()) {
      if (file.exists() && file.getName().toLowerCase().endsWith(".jar")) {
        args "-jar"; args file.getAbsolutePath()
      }
    }

  }
}

Git git = new Git(rootDir)
def versionFile = rootDir.toPath().resolve("versions").resolve("version.txt")
String version = versionFile.text.trim()
String tagName = "snapshot-" + git.currentBranch() + "-" + version

task pushSnapshotTag_incVersionAndCommit() {
  group "docker-lib"
  doFirst {

    Exception error = null

    for (int i = 0; i < 30; i++) {
      try {
        git.tag(tagName, "Delete tag with command: git tag -d " + tagName)
        def remote = git.currentRemote()
        println "6BsxkX5T40 :: push tag ${tagName}"
        git.pushTag(remote, tagName)
        println "i2EWq3OFSE :: tag ${tagName} pushed OK"
        incrementVersionFile(versionFile)
        version = versionFile.text.trim()
        tagName = "snapshot-" + git.currentBranch() + "-" + version
        println "yv01L121S0 :: increment version to ${version} : tagName = ${tagName}"
        println "WM4Gt0d0EA :: tagName = ${tagName}"
        error = null
        git.commitOneFile(
          rootDir.toPath().relativize(versionFile).toString(),
          "SCRIPT: Automatic increment version to ${version}"
        )
        println "Z29GWQ08j5 :: Committed version ${version}"
        break
      } catch (Exception err) {
        error = err
        error.printStackTrace()
        incrementVersionFile(versionFile)
        version = versionFile.text.trim()
        tagName = "snapshot-" + git.currentBranch() + "-" + version
        println "ibnbDyXi5S :: increment version to ${version} : tagName = ${tagName}"
      }
    }

    if (error != null) {
      throw error
    }

  }
}
